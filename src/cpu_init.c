

#include "system.h"
#include "lcd.h"
#include "display.h"
#include "modbus.h"
#include "modbusio.h"

#ifndef NULL
#define NULL 0
#endif

#define nop() asm("NOP")


void Delay_N_mS( unsigned int n_milisecond)  /* n mS delay */
{
    unsigned char i;
    while(n_milisecond--)
    {
        i=17;
        while(i--);
    }
}
void  Delay_10_uS(void)
{
      char i=20;
      while(i--);
}


void SCLK_Init(void)
{
    volatile INT16U i;
    _BIS_SR(SCG0+OSCOFF+SCG1);   //turn off DCO and FLL+
    //SCFQCTL   &=~SCFQ_M; //enable modulation
    nop();
    //SCFI0   |=FN_4+FLLD_1;  //DCO range fDCOCLK =   1.4-12MHz
    //nop();
    //FLL_CTL0    |= XCAP18PF;  //XIN Cap = XOUT Cap = 18pf
    nop();
    //FLL_CTL1    |=FLL_DIV_8;   // ALCK/8
    nop();
    FLL_CTL1    &=~XT2OFF; //turn on xt2  fxt2=8M
    
    do  //wait for stability
    {
        IFG1  &=~OFIFG;   //clear oscillator fault flag
        for(i=0;i<5000;i++);
    }while((IFG1&OFIFG));
    nop();
    //FLL_CTL1    |=0X80; //LF1 digital clock input selecte
    FLL_CTL1    |=SELM1;
    nop();
    FLL_CTL1    |=SELM_XT2+SELS;   //select XT2 as the MCLK and SMCLK
    nop();
}

void IO_Init(void)
{
    //unused io pins  should be configured as io function and output mode
    
    //p2
    P2DIR |=BIT0+BIT3+BIT4+BIT5;
    P2IE  |=BIT2+BIT1;
    P2IES |=0x06;
    P2IFG &=0x00;
    //P3
    P3SEL |=BIT1+BIT2;                 //p3 are used as io pins p3.1,p3.2 I2C
    P3DIR |=BIT0+BIT4+BIT5+BIT6+BIT7;
    //p4
    P4SEL |=BIT3+BIT4+BIT5+BIT6+BIT7; //P4.3,4,5 are used as SPI,uart
    P4DIR |=BIT0+BIT1+BIT2;
    //P5
    P5DIR |=BIT0+BIT2+BIT3+BIT4+BIT5+BIT6+BIT7;//P5.6 UNUSED
    //p6
    P6SEL|=0xff;  //used as analog input
    //P7
    P7DIR |=BIT0+BIT1+BIT2+BIT3+BIT4+BIT5+BIT6+BIT7; //P7.0,2,5,6,7UNUSED
    //P8
    P8DIR |=BIT6+BIT7;  //P8.6,7 UNUSED
    //p9
    P9DIR |=0xff; //P9.0,1 UNUSED
    P10DIR |=0XFF;
}

void SPI_Init(void)
{
    //SPI 8bit master
    U1CTL |=SWRST;
    nop();
    U1CTL |=CHAR+SYNC+MM;       //8-bit master spi mode
    U1TCTL  |=SSEL1+STC+CKPH;   //baud rate generated by SMCLK(8M)
    U1BR0 =0X02;//0x04;         //BAUD RATE =SMCLK/8   1Mhz?
    U1BR1 =0x00;
    U1MCTL  =0x00;
    ME2 |=USPIE1;
	IE2 &= ~(URXIE1+UTXIE1);
    U1CTL &=~SWRST;
    IFG2  &=~(UTXIFG1+URXIFG1); //clear interrupt flags
}

void UART_Init(void)
{
    //UART 8N1
    UCA0CTL1  |= UCSWRST;
    nop();
    UCA0CTL1  |=UCSSEL1;  //baud rate generated by SMCLK(8M)
    //UCA0CTL0  |=UCMSB;    //MSB first, uart mode, 8N1
    
    /*baud rate=9600 (BR0,BR1)=(0x41,0x03)  UCBRSX=0X02     **
    **baud rate=57600  (BR0,BR1)=(0X8A,0X00)  UCBRSX=0X07   **
    **baud rate=1M    (BR0,BR1)=(0X08,0X00)   UCBRSX=0X00   **
    */
    UCA0BR0 =0x41;  //N=SMCLK/BAUD  UCA0BR0+UCA0BR1*256=INT(N)
    UCA0BR1 =0x03;
    UCA0MCTL  =0x02;      //modulation  UCBRSX=round((N-int(N)*8))
    //
    IFG2  &=~UCA0RXIFG;
    UCA0CTL1  &= ~UCSWRST;
    IE2 |=UCA0RXIE;     //enable receive interrupt
}

void I2C_Init(void)
{
    //I2C   7-bit address master mode
    UCB0CTL1  |=UCSWRST;
    UCB0CTL0  |=UCMODE_3+UCSYNC+UCMST; //I2C master sync mode
    UCB0CTL1  |=UCSSEL_2;  //clock source SMCLK
    UCB0I2CSA =0x50;    //slave address is 0x50 AT24C256
    UCB0BR0   =0x19;//0x14;//0xa0;//100K//0x14;        //fclk=SMCLK/20=400K
    UCB0BR1   =0x00;
    UCB0CTL1  &=~UCSWRST;
    IFG2  &=~UCB0RXIFG;
    //UCB0I2CSA =0X50; 
}

void ADC_Init(void)
{
    ADC12CTL0|=SHT10+MSC+REF2_5V+REFON+ADC12ON;
    ADC12CTL1|=SHP+ADC12DIV_3+CONSEQ_3;
    
    ADC12MCTL0|=SREF_1+INCH_0;
    ADC12MCTL1|=SREF_1+INCH_0;
    ADC12MCTL2|=SREF_1+INCH_1;
    ADC12MCTL3|=SREF_1+INCH_1;
    ADC12MCTL4|=SREF_1+INCH_2;
    ADC12MCTL5|=SREF_1+INCH_2;
    ADC12MCTL6|=SREF_1+INCH_3;
    ADC12MCTL7|=SREF_1+INCH_3;
    ADC12MCTL8|=SREF_1+INCH_4;
    ADC12MCTL9|=SREF_1+INCH_4;
    ADC12MCTL10|=SREF_1+INCH_5;
    ADC12MCTL11|=SREF_1+INCH_5;
    ADC12MCTL12|=SREF_1+INCH_6;
    ADC12MCTL13|=SREF_1+INCH_6;
    ADC12MCTL14|=SREF_1+INCH_7;
    ADC12MCTL15|=SREF_1+INCH_7+EOS;
    ADC12IE =0X8000;
    ADC12CTL0|=ENC+ADC12SC;
}

void WDT_Init(void)
{
    WDTCTL = WDTPW+WDTHOLD+WDTTMSEL+WDTCNTCL; //turn off watchdog
}

void TIMERA_Init(void)
{
    TACTL = TASSEL_2+TACLR+ID_3;    //8M时钟源，8分频
    TACCR0 = 0X2710;                //10ms一次中断
    TACCTL0 = CCIE;
    TACTL |= MC_1;   
}

void TIMERB_Init(void)
{
    TBCTL = TBSSEL_2+TBCLR+ID_3;    //8M时钟源，8分频
    TBCCR0 = 0X03E8;                //1ms一次中断
    TBCCTL0 = CCIE;
    TBCTL |= MC_1;   
}

void DAC_Init(void)
{
    DAC12_0CTL|=DAC12OPS+DAC12AMP_5+DAC12ENC;
    DAC12_1CTL|=DAC12OPS+DAC12AMP_5+DAC12ENC;
}

void CPU_Init(void)
{
    _BIC_SR(GIE);   //GIE =0 disable interrupt
    nop();
    WDT_Init();
    nop();
    SCLK_Init();
    IO_Init();
    UART_Init();
    SPI_Init();
    I2C_Init();
    ADC_Init();
    //DAC_init();
    TIMERA_Init();
    TIMERB_Init();
}


void Start_WDT(void)
{
    WDTCTL  =WDTPW;//+WDTIS0+WDTIS1;
}

void Stop_WDT(void)
{
    WDTCTL = WDTPW+WDTHOLD+WDTTMSEL+WDTCNTCL; //turn off watchdog    
}

void Feed_WDT(void)
{
    WDTCTL  =WDTPW+WDTCNTCL;   
}


#pragma vector=TIMERA0_VECTOR
__interrupt void TimerA0_ISR(void)
{
    LEDTimer++;
    KeyTimer++;
    DisplayTimer++;
    RTCTimer++;
    BackLightTimer++;
    MbOtCnt++;
	MbScanCnt++;
	MbIOOtCnt++;
	MbIODelayCnt++;
}

INT16U SoftWDT_Cnt = 0;
#pragma vector=TIMERB0_VECTOR
__interrupt void TimerB0_ISR(void)
{
    //每5s检查一下软狗标志，正常情况下软狗应该在主循环中被置0，
    //如果没有置0，说明程序跑飞，此时启动看门狗
    RTCErrTimer++;
	SoftWDT_Cnt++;
    if(SoftWDT_Cnt > 5000)  
    {
        if(SoftWDT_Flag == 0)
        {
            SoftWDT_Cnt = 0;
            SoftWDT_Flag = 1;
        }
		else
		{
			Start_WDT();
		}
    }
}




